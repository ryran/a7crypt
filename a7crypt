#!/bin/bash
# a7crypt v0.99j last mod 2011/12/01
# Latest version at <http://github.com/ryran/b19scripts>
# Copyright 2011 Ryan Sawhill <ryan@b19.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# System requirements: zenity and one of either gpg, gpg2, or openssl.
#
# The original goal of this project was to make ASCII-armor text-{en,de}cryption
# more accessible and easy to use for people that spend all their time in GUIs.
# That goal has been reached -- in as satisfactory of a way as is possible,
# until I learn python, that is -- so the next piece will be to add the ability
# to encrypt/decrypt files.
#
# It almost goes without saying, but a requirement of this was that security not
# be in any way sacrificed for this convenience.
#
# To that end: no processes are run with arguments of a passphrase, nor are
# passphrases or message data stored on disk; the script creates a working dir
# in ram that is only readable by the current user and whenever message data or
# passphrases need to be stored, they are stored there and deleted as soon as
# they have served their purpose. (Note: We WILL fall-back to creating a working
# dir on disk if /dev/shm is unavailable for some crazy reason.)
#
# We of course want to ensure that all tmpfiles are cleaned up on exit. A simple
# trap will cover exiting due to receiving a sigterm or sigint, but for sigkill,
# we need something more. So each time our script runs, we create lockfiles with
# our PID and the location of the temp working directory. That way, if an old
# instance of the script ever dies without cleaning up its potentially-sensitive
# data, we can take out the trash the next time we run.
#
# When lockfiles & temp directories are created by this script, we name them
# based on the script's current filename; not some static project name. This
# means that you can feel free to rename the script. Everything else will go
# along with the new name--you don't need to change anything in the content.
# One caveat though: Don't put a space in the script name. :)
#  
# Feel free to hit me/the tracker up if you have any questions or suggestions!
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

## Let's set an uber-restrictive umask, because we can
umask 077

## If the filename of our script is /usr/local/bin/a7crypt, then this variable would end up being "a7crypt", which we will use throughout
zero=$(basename "$0")

## Setup settings dotdir in ~ if not already there
dotdir=$HOME/.$zero
[[ -d $dotdir ]] || mkdir $dotdir

## Setup a private working directory in ram or in ~
if [[ -w /dev/shm ]]; then
  wd=$(mktemp -d /dev/shm/.$zero.$UID.XXX)
else
  wd=$(mktemp -d $dotdir/wd.XXX)
fi

## If find any existing lockfiles in home that aren't associated with a running process, then rm them and their stale working dirs
for lockfile in $dotdir/lock-*; do
  [[ $(</proc/${lockfile##*-}/cmdline) = /bin/bash$0 ]] || rm -rv $(readlink $lockfile) $lockfile
done 2>/dev/null

## Create a new lockfile, e.g. ~/.a7crypt/lock-PID, which is a link to our working dir
lockfile=$dotdir/lock-$$
ln -s $wd $lockfile

## Set up our trap to clean-up working dir & kill any child processes (zenity) on exit
trap "{ pkill -P $$; rm -r $wd $lockfile 2>/dev/null; }" EXIT

## Here we create our preset environments for our two (or three) different modes
init_env_GPG2() {
  mode=GPG2; switch_to=OpenSSL
  encrypt="gpg2 --batch --no-tty --yes -ac --force-mdc --passphrase-file $wd/pass --output $wd/output"
  decrypt="gpg2 --batch --no-tty --yes -d --passphrase-file $wd/pass --output $wd/output"
}
init_env_GPG() {
  mode=GPG; switch_to=OpenSSL
  encrypt="gpg --no-use-agent --batch --no-tty --yes -ac --force-mdc --passphrase-file $wd/pass --output $wd/output"
  decrypt="gpg --no-use-agent --batch --no-tty --yes -d --passphrase-file $wd/pass --output $wd/output"
}
init_env_OPENSSL() {
  mode=OpenSSL-AES; switch_to=GPG
  encrypt="openssl aes-256-cbc -a -salt -pass file:$wd/pass -out $wd/output"
  decrypt="openssl aes-256-cbc -a -d -pass file:$wd/pass -out $wd/output"
}


##------------------------------------------------------------------------------
## THE MAIN MENU -- the framework which everything plugs into                  |
##                                                                             |
MAIN() {                                                                    #---

## If in openssl mode, explain to user about openssl, and give a chance to hide warnings
if [[ $mode = OpenSSL-AES && ! -f /tmp/$zero.nowarn.$UID ]]; then
  zenity --question --title="$zero [$mode]: NOTICE" --text="You're running in OpenSSL mode -- either by choice, or because we could not locate GPG1 or 2. This mode uses the command \"openssl aes-256-cbc\" to encrypt your text and \"openssl aes-256-cbc -a -d\" for decryption. I'm telling you because OpenSSL doesn't add any pretty info to your encrypted message (like GPG does) which would remind you what format the data is in, nor is OpenSSL single-minded enough to decrypt a block of text you pass to it without using the proper arguments." --cancel-label="Understood, don't tell me again for a while" --ok-label="OK" --no-markup || touch /tmp/$zero.nowarn.$UID
fi

## Initial main menu choice
menu_choice=$(zenity --list --radiolist --hide-header --title="$zero [$mode]" --text="What would you like to do?" --column=1 --column=2 TRUE Encrypt FALSE Decrypt FALSE "Switch to $switch_to-mode" --cancel-label="Quit") ||  exit

## Commented up the encrytion block, which is pretty much the same as the decryption one
if [[ $menu_choice = Encrypt ]]; then
  ## Ask for ascii message to be encrypted
  zenity --text-info --editable --title="$zero [$mode]: Type or paste text to be encrypted" --width=800 --height=600 --no-wrap >$wd/input || MAIN
  ## Keep prompting until user actually enters some data
  until [[ -s $wd/input ]]; do
    zenity --text-info --editable --title="$zero [$mode]: You must enter text to be encrypted" --width=800 --height=600 --no-wrap >$wd/input || MAIN
  done
  ## Ask for encryption passphrase
  zenity --entry --title="$zero [$mode]" --text="Enter passphrase very carefully" --ok-label="Encrypt" >$wd/pass || MAIN
  ## Keep prompting until user enters a passphrase (zenity --entry is different than --text-info; if no input, it creates a 1byte file instead of 0byte)
  until [[ $(wc -c <$wd/pass) -gt 1 ]]; do
    zenity --entry --title="$zero [$mode]" --text="You must enter a passphrase" --ok-label="Encrypt" >$wd/pass || MAIN
  done
  ## Start a progress bar dialog for those really big jobs or slow machines (this gives the user feedback and a chance to cancel)
  coproc zenity --progress --pulsate --title="$mode: Encrypting" --text="Please wait." --auto-kill --auto-close; echo 1 >&${COPROC[1]}
  ## Run our encrytion; if failed, save & report back errors, cleanup, and go to main menu
  if ! $encrypt <$wd/input 2>$wd/errlog; then
    echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes
    zenity --error --title="$zero [$mode]: ENCRYPTION ERROR!" --text="$(<$wd/errlog)" --no-wrap
    >$wd/pass; >$wd/input
    MAIN
  fi
  echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes
  ## Clear the passphrase & input buffers ASAP, just because we can
  >$wd/pass; >$wd/input
  ## Display encrypted data back to user, loop back to main menu if they don't hit quit
  zenity --text-info --title="$zero [$mode]: Your encrypted text" --width=650 --height=600 --no-wrap --cancel-label="Quit" --ok-label="Menu" <$wd/output || exit
  >$wd/output
  MAIN

elif [[ $menu_choice = Decrypt ]]; then
  zenity --text-info --editable --title="$zero [$mode]: Paste $mode-encrypted message" --width=650 --height=600 --no-wrap >$wd/input || MAIN
  until [[ -s $wd/input ]]; do
    zenity --text-info --editable --title="$zero [$mode]: You must enter an encrypted message" --width=800 --height=600 --no-wrap >$wd/input || MAIN
  done
  zenity --entry --title="$zero [$mode]" --text="Enter passphrase" --ok-label="Decrypt" >$wd/pass || MAIN
  until [[ $(wc -c <$wd/pass) -gt 1 ]]; do
    zenity --entry --title="$zero [$mode]" --text="You must enter a passphrase" --ok-label="Decrypt" >$wd/pass || MAIN
  done
  coproc zenity --progress --pulsate --title="$mode: Decrypting" --text="Please wait." --auto-kill --auto-close; echo 1 >&${COPROC[1]}
  if ! $decrypt <$wd/input 2>$wd/errlog; then
    echo 100 >&${COPROC[1]}
    zenity --error --title="$zero [$mode]: DECRYPTION ERROR!" --text="$(<$wd/errlog)" --no-wrap
    >$wd/pass; >$wd/input
    MAIN
  fi
  echo 100 >&${COPROC[1]}
  >$wd/pass; >$wd/input
  zenity --text-info --title="$zero [$mode]: Your decrypted text" --width=800 --height=600 --no-wrap --cancel-label="Quit" --ok-label="Menu" <$wd/output || exit
  >$wd/output
  MAIN

## If they didn't choose Encrypt or Decrypt, then they chose to switch modes
else
  ## If switching to openssl mode, ensure we have openssl (haha) and initialize our variables (see init_env_* functions at the top)
  if [[ $switch_to = OpenSSL ]]; then
    if command -v openssl >/dev/null; then
      init_env_OPENSSL
    else
      zenity --error --title="Missing OpenSSL" --text="OpenSSL not found in your \$PATH. That's so shocking I almost don't believe it. In any case, if you really want to try it out, you can install it using your software-management application." --width=400
    fi
  ## If switching to gpg mode, check for gpg2, first; otherwise gpg; in the unlikely event of neither, display an error
  elif [[ $switch_to = GPG ]]; then
    if command -v gpg2 >/dev/null; then
      init_env_GPG2
    elif command -v gpg >/dev/null; then
      init_env_GPG
    else
      zenity --error --title="Missing GPG" --text="Neither GPG nor GPG2 were found in your \$PATH. You can install either of them using your software-management application." --width=400
    fi
  fi
  ## Reload the main menu
  MAIN
fi
}



##------------------------------------------------------------------------------
## BEGINNING                                                                   |
##                                                                             |
## If user runs this script with arguments, display a message                  |
if [ $# -ne 0 ]; then                                                       #---
  echo -e "Provides simple symmetric text encryption/decryption using GPG, GPG2, or OpenSSL\nMeant to be run interactively (no args) from the desktop -- Zenity is required"
  exit
## Ensure we have zenity
elif ! command -v zenity >/dev/null; then
  echo -e "This program relies on Zenity (which you don't have) for user-interaction\nYou can easily install it from your software-management app"
  exit 1
## Prefer gpg2; if we have it, initialize our variables
elif command -v gpg2 >/dev/null; then
  init_env_GPG2
## Next up, check for gpg
elif command -v gpg >/dev/null; then
  init_env_GPG
## Finally, if no gpg funness, use openssl
elif command -v openssl >/dev/null; then
  init_env_OPENSSL
## In the off-chance that none of those three are on the system, warn the user that we're on to them
else
  zenity --error --title="You pulling my leg?" --text='Neither GPG, GPG2, nor OpenSSL were found in your $PATH..? Right. If you say so. Use your software-management application to install one of them.' --width=400
  exit 1
fi

## Now that we know what mode we're running in, start main menu
MAIN
