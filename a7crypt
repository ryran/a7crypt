#!/bin/bash
# a7crypt v1.0.0-RC2 last mod 2011/12/01
# Latest version at <http://github.com/ryran/b19scripts>
# Copyright 2011 Ryan Sawhill <ryan@b19.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# System requirements: zenity and one of either gpg, gpg2, or openssl.
#
# The original goal of this project was to make symmetric text {en,de}cryption
# more accessible and easy to use for people that spend all their time in GUIs.
# After accomplishing that, I added the ability to pick files and potentially do
# binary output. The focus is still on symmetric encryption--there are frontends
# for key-based encrypting & decrypting.
#
# It almost goes without saying, but from the beginning, a requirement of all
# this was that security not be in any way sacrificed for the convenience. 
#
# To that end: No processes are run with arguments of a passphrase, nor are
# passphrases or message data stored on disk; the script creates a working dir
# in ram that is only readable by the current user and whenever message data or
# passphrases need to be stored, they are stored there and deleted as soon as
# they have served their purpose. (Note: We WILL fall-back to creating a working
# dir on disk in HOME if /dev/shm is unavailable for some crazy reason.)
#
# We of course want to ensure that all tmpfiles are cleaned up on exit. A simple
# trap will cover exiting due to receiving a sigterm or sigint, but for sigkill,
# we need something more. So each time the script runs it creates lockfiles with
# its PID and the location of the temp working directory. That way, if an old
# instance of the script ever dies without cleaning up its potentially-sensitive
# data, we can take out the trash on the next run.
#
# When lockfiles & temp directories are created by this script, they're named
# based on the script's current filename; not some static project name. This
# means that you can feel free to rename the script. Everything else will go
# along with the new name--you don't need to change anything in the content.
# One caveat though: Don't put a space in the script name. :)
#  
# Feel free to hit me/the tracker up if you have any questions or suggestions!
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------

## Let's set an uber-restrictive umask, because we can
umask 077

## If the filename of our script is /usr/local/bin/a7crypt, then this variable would end up being "a7crypt", which we will use throughout
zero=$(basename "$0")

## Setup settings dotdir in ~ if not already there
dotdir=$HOME/.$zero
[[ -d $dotdir ]] || mkdir $dotdir

## Setup a private working directory in ram or in ~
if [[ -w /dev/shm ]]; then
  wd=$(mktemp -d /dev/shm/.$zero.$UID.XXX)
else
  wd=$(mktemp -d $dotdir/wd.XXX)
fi

## If find any existing lockfiles in home that aren't associated with a running process, then rm them and their stale working dirs
for lockfile in $dotdir/lock-*; do
  [[ $(</proc/${lockfile##*-}/cmdline) = /bin/bash$0 ]] || rm -rv $(readlink $lockfile) $lockfile
done 2>/dev/null

## Create new lockfile, e.g. ~/.a7crypt/lock-PID, which is a link to the working dir
lockfile=$dotdir/lock-$$
ln -s $wd $lockfile

## Set up trap to clean-up working dir & kill any child processes (zenity) on exit
trap "{ pkill -P $$; rm -r $wd $lockfile 2>/dev/null; }" EXIT

## Set filemgr for giving the option to have a look at encrypted files
for f in nautilus dolphin konqueror thunar pcmanfm firefox; do
  command -v $f >/dev/null && { filemgr=$f; break; }
done

## Here we create preset environments for the different modes
init_env_GPG2() {
  switch_to=OpenSSL
  encrypt="gpg2 --batch --no-tty --yes -c --force-mdc --passphrase-file $wd/pass --output $wd/output"
  decrypt="gpg2 --batch --no-tty --yes -d --passphrase-file $wd/pass --output $wd/output"
}
init_env_GPG() {
  switch_to=OpenSSL
  encrypt="gpg --no-use-agent --batch --no-tty --yes -c --force-mdc --passphrase-file $wd/pass --output $wd/output"
  decrypt="gpg --no-use-agent --batch --no-tty --yes -d --passphrase-file $wd/pass --output $wd/output"
}
init_env_OPENSSL() {
  switch_to=GPG
  encrypt="openssl aes-256-cbc -salt -pass file:$wd/pass -out $wd/output"
  decrypt="openssl aes-256-cbc -d -pass file:$wd/pass -out $wd/output"
}

## Set main menu veriables for zenity --list
menu_head_enc="[----- ENCRYPTION -----]"
menu_enc_text="  • Type or paste text"
menu_enc_file="  • Select file"
menu_head_dec="[----- DECRYPTION -----]"
menu_dec_text="  • Paste text"
menu_dec_file="  • Select file"
menu_blanksep="  --------------------------"
#             "Switch to $switch_to-mode"


##------------------------------------------------------------------------------
## THE MAIN MENU -- the framework which everything plugs into                  |
##                                                                             |
MAIN() {                                                                    #---

## (re-)Initialize our variables, depending on which mode we're in
if [[ $mode = GPG2 ]]; then
  init_env_GPG2
elif [[ $mode = GPG ]]; then
  init_env_GPG
elif [[ $mode = OpenSSL-AES ]]; then
  init_env_OPENSSL
fi

## INITIAL MAIN MENU CHOICES
menu_choice=$(zenity --list --hide-header --title="$zero [$mode]" --text="What would you like to do?" --column=1 "$menu_head_enc" "$menu_enc_text" "$menu_enc_file" "$menu_head_dec" "$menu_dec_text" "$menu_dec_file" "$menu_blanksep" "Switch to $switch_to-mode" --cancel-label="Quit" --height=310) ||  exit
#--width=220 

##-----------------------------------------------
## BEGIN PARSING MENU CHOICES
## Reload menu if user picks one of the header lines
if [[ $menu_choice = $menu_head_enc || $menu_choice = $menu_head_dec || $menu_choice = "$menu_blanksep" ]]; then
  MAIN

##-----------------------------------------------
## ENCRYPT: TYPE/PASTE TEXT
elif [[ $menu_choice = $menu_enc_text ]]; then

  ## Warn user about openssl obscurity
  if [[ $mode = OpenSSL-AES && ! -f $dotdir/nowarn.openssl-txt ]]; then
    zenity --info --title="$zero [$mode]: NOTICE" --text="OpenSSL text-input mode uses <tt>'openssl aes-256-cbc -salt -a'</tt> to encrypt text to ASCII-armored (plain-text) output. OpenSSL doesn't add any pretty envelope info to its encrypted data like GPG does, meaning there are no GUI applications (AFAIK) that will know what to do with files containing said data.\n\n<span foreground='red' weight='bold'>In short, to decrypt data encrypted with this mode, you can either:</span>\n1) use this app\n2) use OpenSSL directly on a terminal, i.e., drop the data into a file of <i><tt>SOMENAME</tt></i> and run\n\t<tt>openssl aes-256-cbc -a -d -in <i>SOMENAME</i></tt>\n\n<b>[Press Enter or Esc if you can't see OK button.]</b>"
    touch $dotdir/nowarn.openssl-txt
  fi

  ## We have to add some things to the default encrypt string
  encrypt="$encrypt -a"

  ## Ask for text message to be encrypted
  zenity --text-info --editable --title="$zero [$mode]: Type or paste text to be encrypted" --width=800 --height=600 --no-wrap >$wd/input || MAIN

  ## Keep prompting until user actually enters some data
  until [[ -s $wd/input ]]; do
    zenity --text-info --editable --title="$zero [$mode]: You must enter text to be encrypted" --width=800 --height=600 --no-wrap >$wd/input || MAIN
  done

  ## Ask for encryption passphrase
  zenity --entry --title="$zero [$mode]" --text="Enter passphrase very carefully" --ok-label="Encrypt" >$wd/pass || MAIN

  ## Keep prompting until user enters a passphrase (zenity --entry inserts a newline even if no input so we can't use "test -s" like we can with --text-info)
  until [[ $(wc -c <$wd/pass) -gt 1 ]]; do
    zenity --entry --title="$zero [$mode]" --text="You must enter a passphrase" --ok-label="Encrypt" >$wd/pass || MAIN
  done

  ## Start a progress bar dialog for those really big jobs or slow machines (this gives the user feedback and a chance to cancel)
  coproc zenity --progress --pulsate --title="$mode: Encrypting" --text="Please wait." --auto-kill --auto-close; echo 1 >&${COPROC[1]}

  ## Run our encrytion; if failed, save & report back errors, cleanup, and go to main menu
  if ! $encrypt <$wd/input 2>$wd/errlog; then
    >$wd/pass; >$wd/input
    echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes
    zenity --error --title="$zero [$mode]: ENCRYPTION ERROR!" --text="$(<$wd/errlog)" --no-wrap
    MAIN
  fi

  ## If encryption succeeded... 
  >$wd/pass; >$wd/input ## Clear the passphrase & input buffers ASAP, just because we can
  echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes

  ## Display encrypted data back to user, loop back to main menu if they don't hit quit
  zenity --text-info --title="$zero [$mode]: Your encrypted text" --width=650 --height=600 --no-wrap --cancel-label="Quit" --ok-label="Menu" <$wd/output || exit
  >$wd/output
  MAIN


##-----------------------------------------------
## ENCRYPT: SELECT FILE
elif [[ $menu_choice = $menu_enc_file ]]; then

  ## Warn user about openssl obscurity
  if [[ $mode = OpenSSL-AES && ! -f $dotdir/nowarn.openssl-file ]]; then
    zenity --info --title="$zero [$mode]: NOTICE" --text="OpenSSL file-input mode uses <tt>'openssl aes-256-cbc -salt'</tt> to encrypt non-text files to binary output and the same plus an option of <tt>'-a'</tt> to encrypt text files to ASCII-armored (plain-text) output. (Output files get the same name with an extension of <tt>'aes256'</tt> appended.) OpenSSL doesn't add any pretty envelope info to its encrypted data like GPG does, meaning there are no GUI applications (AFAIK) that will know what to do with files containing said data.\n\n<span foreground='red' weight='bold'>In short, to decrypt files encrypted with this mode, you can either:</span>\n1) use this app\n2) use OpenSSL directly on a terminal, e.g.,\n<tt>  openssl aes-256-cbc -a -d -in <i>FILE.txt.aes256</i></tt>\n\t(to decrypt the ASCII-files)\n<tt>  openssl aes-256-cbc -d -in <i>FILE.zip.aes256</i></tt>\n\t(to decrypt the binary files)\n\n<b>[Press Enter or Esc if you can't see OK button.]</b>"
    touch $dotdir/nowarn.openssl-file
  fi

  ## Get file to encrypt via file-selection dialog
  file_to_encrypt=$(zenity --file-selection --title="$zero [$mode]: Select file to be encrypted")|| MAIN

  ## Keep prompting until user chooses a proper file
  while [[ ! -s $file_to_encrypt || ! -r $file_to_encrypt ]]; do
    file_to_encrypt=$(zenity --file-selection --title="$zero [$mode]: Could not read file; select another")|| MAIN
  done
  
  ## Detect whether input is binary or text and set output mode and output filename accordingly
  file_type=$(file -b -e soft "$file_to_encrypt") ## Get filetype
  if [[ ${file_type%% *} = ASCII ]]; then
    encrypt="$encrypt -a"; ascii_yesno="ASCII-armored output"
    [[ $mode = OpenSSL-AES ]] && encrypted_file=$file_to_encrypt.aes256 || encrypted_file=$file_to_encrypt.asc
  else
    ascii_yesno="binary output"
    [[ $mode = OpenSSL-AES ]] && encrypted_file=$file_to_encrypt.aes256 || encrypted_file=$file_to_encrypt.gpg
  fi

  ## Now that we know what our input and output files are going to be, setup symlinks
  ln -sf "$file_to_encrypt" $wd/input
  ln -sf "$encrypted_file" $wd/output

  ## Ask for encryption passphrase
  zenity --entry --title="$zero [$mode]" --text="Enter passphrase very carefully" --ok-label="Encrypt" >$wd/pass || MAIN

  ## Keep prompting until user enters a passphrase (zenity --entry inserts a newline even if no input so we can't use "test -s" like we can with --text-info)
  until [[ $(wc -c <$wd/pass) -gt 1 ]]; do
    zenity --entry --title="$zero [$mode]" --text="You must enter a passphrase" --ok-label="Encrypt" >$wd/pass || MAIN
  done

  ## Start a progress bar dialog for those really big jobs or slow machines (this gives the user feedback and a chance to cancel)
  coproc zenity --progress --pulsate --title="$mode: Encrypting" --text="Please wait." --auto-kill --auto-close; echo 1 >&${COPROC[1]}

  ## Run our encrytion; if failed, save & report back errors, cleanup, and go to main menu
  if ! $encrypt <$wd/input 2>/$wd/errlog; then
    >$wd/pass; rm $wd/input $wd/output
    echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes
    zenity --error --title="$zero [$mode]: ENCRYPTION ERROR!" --text="$(<$wd/errlog)" --no-wrap
    MAIN
  fi

  ## If encryption succeeded... 
  >$wd/pass; rm $wd/input $wd/output ## Clear the passphrase buffer and rm symlinks
  echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes

  ## Report final encrypted filename back to user; give them a chance to see the file in their filemanager (hopefully)
  echo -en "Successfully encrypted [ $file_to_encrypt ] with $ascii_yesno. Saved encrypted copy to:\n$encrypted_file" | zenity --text-info --title="$zero [$mode]: Your encrypted file is ready" --width=500 --height=160 --cancel-label="Show me file" --ok-label="Menu" || $filemgr "${encrypted_file%/*}"
  MAIN


##-----------------------------------------------
## DECRYPT: PASTE ENCRYPTED ASCII
elif [[ $menu_choice = $menu_dec_text ]]; then

  ## We have to add some things to the default decrypt string
  decrypt="$decrypt -a"

  ## Ask for text message to be decrypted
  zenity --text-info --editable --title="$zero [$mode]: Paste $mode-encrypted message" --width=650 --height=600 --no-wrap >$wd/input || MAIN

  ## Keep prompting until user actually enters some data
  until [[ -s $wd/input ]]; do
    zenity --text-info --editable --title="$zero [$mode]: You must enter an encrypted message" --width=800 --height=600 --no-wrap >$wd/input || MAIN
  done

  ## Ask for decryption passphrase
  zenity --entry --title="$zero [$mode]" --text="Enter passphrase" --ok-label="Decrypt" >$wd/pass || MAIN

  ## Keep prompting until user enters a passphrase (zenity --entry inserts a newline even if no input so we can't use "test -s" like we can with --text-info)
  until [[ $(wc -c <$wd/pass) -gt 1 ]]; do
    zenity --entry --title="$zero [$mode]" --text="You must enter a passphrase" --ok-label="Decrypt" >$wd/pass || MAIN
  done

  ## Start a progress bar dialog for those really big jobs or slow machines (this gives the user feedback and a chance to cancel)
  coproc zenity --progress --pulsate --title="$mode: Decrypting" --text="Please wait." --auto-kill --auto-close; echo 1 >&${COPROC[1]}

  ## Run our decrytion; if failed, save & report back errors, cleanup, and go to main menu
  if ! $decrypt <$wd/input 2>$wd/errlog; then
    >$wd/pass; >$wd/input
    echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes
    zenity --error --title="$zero [$mode]: DECRYPTION ERROR!" --text="$(<$wd/errlog)" --no-wrap
    MAIN
  fi

  ## If decryption succeeded... 
  >$wd/pass; >$wd/input ## Clear the passphrase & input buffers ASAP, just because we can
  echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes

  ## Display decrypted data back to user, loop back to main menu if they don't hit quit
  zenity --text-info --title="$zero [$mode]: Your decrypted text" --width=800 --height=600 --no-wrap --cancel-label="Quit" --ok-label="Menu" <$wd/output || exit
  >$wd/output
  MAIN


##-----------------------------------------------
## DECRYPT: SELECT FILE
elif [[ $menu_choice = $menu_dec_file ]]; then

  ## Get file to decrypt via file-selection dialog
  file_to_decrypt=$(zenity --file-selection --title="$zero [$mode]: Select file to be decrypted")|| MAIN

  ## Keep prompting until user chooses a proper file
  while [[ ! -s $file_to_decrypt || ! -r $file_to_decrypt ]]; do
    file_to_decrypt=$(zenity --file-selection --title="$zero [$mode]: Could not read file; select another")|| MAIN
  done

  ## Try to figure out what to suggest for the save dialog box
  ## We start with a default, but if the file ends in .asc or .gpg or .aes256, set the suggestion to the filename minus that extension
  decrypted_file_suggestion=${file_to_decrypt}-decrypted
  for ext in .asc .gpg .aes256; do
    [[ ${file_to_decrypt%$ext} = $file_to_decrypt ]] || { decrypted_file_suggestion=${file_to_decrypt%$ext}; break; }
  done

  ## Prompt user for where to save decrypted file
  decrypted_file=$(zenity --file-selection --save --confirm-overwrite --filename="$decrypted_file_suggestion" --title="$zero [$mode]: Choose decrypted file name of '${file_to_decrypt##*/}'") || MAIN

  ## Prevent user from nuking their file by reading and writing to it at the same time
  while [[ $file_to_decrypt = $decrypted_file ]]; do
    zenity --error --title="I just saved your life" --text="Source and destination files cannot be the same!" 
    decrypted_file=$(zenity --file-selection --save --confirm-overwrite --filename="$decrypted_file_suggestion" --title="$zero [$mode]: Choose decrypted file name of '${file_to_decrypt##*/}'") || MAIN
  done

  ## Set ascii option for openssl, if needed
  if [[ $mode = OpenSSL-AES ]]; then
    file_type=$(file -b -e soft "$file_to_decrypt") ## Get filetype
    [[ ${file_type%% *} = ASCII ]] && decrypt="$decrypt -a"
  fi

  ## Now that we know what our input and output files are going to be, setup symlinks
  ln -sf "$file_to_decrypt" $wd/input
  ln -sf "$decrypted_file" $wd/output
  
  ## Ask for decryption passphrase
  zenity --entry --title="$zero [$mode]" --text="Enter passphrase" --ok-label="Decrypt" >$wd/pass || MAIN

  ## Keep prompting until user enters a passphrase (zenity --entry inserts a newline even if no input so we can't use "test -s" like we can with --text-info)
  until [[ $(wc -c <$wd/pass) -gt 1 ]]; do
    zenity --entry --title="$zero [$mode]" --text="You must enter a passphrase" --ok-label="Decrypt" >$wd/pass || MAIN
  done

  ## Start a progress bar dialog for those really big jobs or slow machines (this gives the user feedback and a chance to cancel)
  coproc zenity --progress --pulsate --title="$mode: Decrypting" --text="Please wait." --auto-kill --auto-close; echo 1 >&${COPROC[1]}

  ## Run our decryption; if failed, save & report back errors, cleanup, and go to main menu
  if ! $decrypt <$wd/input 2>/$wd/errlog; then
    >$wd/pass; rm $wd/input $wd/output
    echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes
    zenity --error --title="$zero [$mode]: DECRYPTION ERROR!" --text="$(<$wd/errlog)" --no-wrap
    MAIN
  fi

  ## If decryption succeeded... 
  >$wd/pass; rm $wd/input $wd/output ## Clear the passphrase buffer and rm symlinks
  echo 100 >&${COPROC[1]} ## Set our progress dialog to 100% so it closes

  ## Report final decrypted filename back to user; give them a chance to see the file in their filemanager (hopefully)
  echo -en "Successfully decrypted [ $file_to_decrypt ] to new file:\n$decrypted_file" | zenity --text-info --title="$zero [$mode]: Your decrypted file is ready" --width=500 --height=160 --cancel-label="Show me file" --ok-label="Menu" || $filemgr "${decrypted_file%/*}"
  MAIN


##-----------------------------------------------
## SWITCH MODES
else

  ## If switching to openssl mode, ensure we have openssl (haha) before setting our mode
  if [[ $switch_to = OpenSSL ]]; then
    if command -v openssl >/dev/null; then
      mode=OpenSSL-AES
    else
      zenity --error --title="Missing OpenSSL" --text="OpenSSL not found in your \$PATH. That's so shocking I almost don't believe it. In any case, if you really want to try it out, you can install it using your software-management application." --width=400
    fi

  ## If switching to gpg mode, check for gpg2 first; otherwise gpg; in the unlikely event of neither, display an error
  elif [[ $switch_to = GPG ]]; then
    if command -v gpg2 >/dev/null; then
      mode=GPG2
    elif command -v gpg >/dev/null; then
      mode=GPG
    else
      zenity --error --title="Missing GPG" --text="Neither GPG nor GPG2 were found in your \$PATH. You can install either of them using your software-management application." --width=400
    fi
  fi

  ## Reload the main menu
  MAIN
fi
}



##------------------------------------------------------------------------------
## BEGINNING                                                                   |
##                                                                             |
## If user runs this script with arguments, display a message                  |
if [ $# -ne 0 ]; then                                                       #---
  echo -e "Provides simple symmetric encryption/decryption using GPG, GPG2, or OpenSSL\nMeant to be run interactively (w/ no arguments) from the desktop"
  exit

## Ensure we have zenity
elif ! command -v zenity >/dev/null; then
  echo -e "This program relies on Zenity (which you don't have) for user-interaction\nYou can easily install it from your software-management app"
  exit 1

## Prefer gpg2
elif command -v gpg2 >/dev/null; then
  mode=GPG2

## Next up, check for gpg
elif command -v gpg >/dev/null; then
  mode=GPG

## Finally, if no gpg funness, use openssl
elif command -v openssl >/dev/null; then
  mode=OpenSSL-AES

## In the off-chance that none of those three are on the system, warn the user that we're on to them
else
  zenity --error --title="You pulling my leg?" --text='Neither GPG, GPG2, nor OpenSSL were found in your $PATH..? Right. If you say so. Use your software-management application to install one of them.' --width=400
  exit 1
fi

## First-run information
if [[ ! -f $dotdir/nowarn.1strun ]]; then
  zenity --info --title="$zero: First-run message" --text="This app is designed to be a frontend for utilities that provide symmetric (i.e., one passphrase used for both) encryption and decryption of files or blocks of text. It doesn't set any limits on the size of the input, so be warned: if e.g., you paste in a 150 MB text file for encryption, $zero will do it, but you'll lose upwards of 150 megs of RAM temporarily as it stores input in /dev/shm to speed operations. So you'd be better off using the file-selection mode for giant text files, as the file will be fed directly into the encryption program. Enjoy\!\n\n<b>[Press Enter or Esc if you can't see OK button.]</b>"
  touch $dotdir/nowarn.1strun
fi

## Now that we know what mode we're running in, start main menu
MAIN
